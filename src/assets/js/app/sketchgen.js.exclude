var canvasManager = {
    // Canvas object
    canvasObject: null,

    // Init and binding
    initCanvas: function () {
        fabric.Object.prototype.objectCaching = false;
        this.canvasObject = window._canvas = new fabric.Canvas(app.config.sketchCanv, {
            imageSmoothingEnabled: false,
            renderOnAddRemove: false,
            stateful: false,
            hoverCursor: "pointer",
            selection: false,
            isDrawingMode: false // Set that to true for hand drawing
        });

        canvasManager.bindCanvasEvents();

        // Init Free Drawing Values
        canvasManager.canvasObject.freeDrawingBrush.width = 5;
        canvasManager.canvasObject.freeDrawingBrush.color = "rgba(255, 0, 0, 0.5)";
    },
    bindCanvasEvents: function () {
        this.canvasObject.on("object:moving", function (e) {
            window._target = e.target;
            const p = e.target;
            const origin = sketchManager.sketchObject.service.sub.customRadious;
            p.line1 && p.line1.set({ "x2": p.left + origin, "y2": p.top + origin });
            p.line2 && p.line2.set({ "x1": p.left + origin, "y1": p.top + origin });
            p.line3 && p.line3.set({ "x1": p.left + origin, "y1": p.top + origin });
            p.line4 && p.line4.set({ "x1": p.left + origin, "y1": p.top + origin });

            if (p.line1) {
                sketchManager.sketchObject.service.sub.customCoords[e.target.id].x1 = p.line1.x1;
                sketchManager.sketchObject.service.sub.customCoords[e.target.id].y1 = p.line1.y1;
                sketchManager.sketchObject.service.sub.customCoords[e.target.id].x2 = p.line1.x2;
                sketchManager.sketchObject.service.sub.customCoords[e.target.id].y2 = p.line1.y2;
            }

            if (p.line2) {
                sketchManager.sketchObject.service.sub.customCoords[e.target.id + 1].x1 = p.line2.x1;
                sketchManager.sketchObject.service.sub.customCoords[e.target.id + 1].y1 = p.line2.y1;
                sketchManager.sketchObject.service.sub.customCoords[e.target.id + 1].x2 = p.line2.x2;
                sketchManager.sketchObject.service.sub.customCoords[e.target.id + 1].y2 = p.line2.y2;
            }
        });

        this.canvasObject.on("path:created", function (opt) {
            opt.path.id = opt.path.xid = `path_${fabric.Object.__uid++}`;
            opt.path.type = "path";

            sketchManager.sketchObject.paths.push(opt.path);
            canvasManager.finalizeRendering();
        });

        this.canvasObject.on("object:selected", function () {
            if (canvasManager.canvasObject.getActiveObject().type === "path")
                $("#freeDrawingPanel").removeClass("inactivePanel").addClass("activePanel");
            else
                $("#freeDrawingPanel").removeClass("activePanel").addClass("inactivePanel");
        });

        this.canvasObject.on("before:selection:cleared", function () {
            $("#freeDrawingPanel").removeClass("activePanel").addClass("inactivePanel");
        });
    },

    plotGrid: function () {
        const grid = app.config.gridSize;
        const gridArray = [];
        canvasManager.canvasObject.renderOnAddRemove = false;

        for (let i = 0; i < (sketchManager.sketchObject.canvas.width / grid); i++) {
            gridArray.push(new fabric.Line([i * grid, 0, i * grid, sketchManager.sketchObject.canvas.height], { stroke: "#ccc", strokeWidth: 0.5, selectable: false }));
        }

        for (let i = 0; i < (sketchManager.sketchObject.canvas.height / grid); i++) {
            gridArray.push(new fabric.Line([0, i * grid, sketchManager.sketchObject.canvas.width, i * grid], { stroke: "#ccc", strokeWidth: 0.5, selectable: false }));
        }

        const gridGroup = new fabric.Group(gridArray,
            {
                id: "grid",
                selectable: false,
                objectCaching: false,
                opacity: 0
            });
        canvasManager.canvasObject.add(gridGroup);
    },

    plotText: function (text, color, x, y, isVertical, isCentered, isSmallerFont, backgroundColor) {
        let calcFontSize = (sketchManager.sketchObject.canvas.margin / (isSmallerFont ? 2 : 1.5)).toFixed(2) / 1;
        calcFontSize = calcFontSize < 12 ? 12 : calcFontSize;

        const txt = new fabric.Text(text, {
            fontFamily: "Arial",
            fill: color,
            fontSize: calcFontSize,
            left: x,
            top: y,
            angle: isVertical ? 90 : 0,
            selectable: false,
            hasControls: true,
            hasRotatingPoint: false,
            objectCaching: false,
            textBackgroundColor: backgroundColor
        });

        if (isCentered) {
            txt.left -= txt.getBoundingRectWidth() / 2;
            txt.top -= txt.getBoundingRectHeight() / 2;
        }

        this.canvasObject.add(txt);
    },
    plotRectangle: function (cord, thickness, fillColor, fillOpacity, borderColor, fillPattern) {
        var rect = new fabric.Rect({
            top: cord.top,
            left: cord.left,
            width: cord.width,
            height: cord.height,
            fill: fillColor,
            stroke: borderColor,
            strokeWidth: thickness,
            opacity: fillOpacity,
            selectable: false,
            objectCaching: false
        });
        this.canvasObject.add(rect);

        if (fillPattern) {
            fabric.util.loadImage("assets/images/tile.jpg", function (img) {
                rect.set("fill", new fabric.Pattern({ source: img, repeat: "repeat" }));
                canvasManager.finalizeRendering();
            });
        };
    },
    plotLine: function (cord, thickness, fillColor, isDashed) {
        this.canvasObject.add(new fabric.Line([cord.x1, cord.y1, cord.x2, cord.y2], {
            strokeWidth: thickness,
            strokeDashArray: isDashed ? [thickness * 4, thickness * 2] : [],
            stroke: fillColor,
            objectCaching: false,
            selectable: false
        }));
    },
    plotMeasurementLine: function (cord, thickness, fillColor, isDashed, measurementText, isHorizontal) {
        const lines = [];
        // Main line
        lines.push(new fabric.Line([cord.x1, cord.y1, cord.x2, cord.y2],
            {
                strokeWidth: thickness,
                strokeDashArray: isDashed ? [thickness * 4, thickness * 2] : [],
                stroke: fillColor,
                selectable: false
            }));

        lines.push(new fabric.Line([cord.x1 - sketchManager.sketchObject.canvas.margin / 2, cord.y1, cord.x2 + sketchManager.sketchObject.canvas.margin / 2, cord.y1],
            {
                strokeWidth: thickness,
                strokeDashArray: isDashed ? [thickness * 4, thickness * 2] : [],
                stroke: appHelper.shadeColor(app.colors.measurementTopLine, 50),
                selectable: false
            }));

        lines.push(new fabric.Line([cord.x1 - sketchManager.sketchObject.canvas.margin / 2, cord.y2, cord.x2 + sketchManager.sketchObject.canvas.margin / 2, cord.y2],
            {
                strokeWidth: thickness,
                strokeDashArray: isDashed ? [thickness * 4, thickness * 2] : [],
                stroke: appHelper.shadeColor(app.colors.measurementTopLine, 50),
                selectable: false
            }));

        canvasManager.canvasObject.add(new fabric.Group(lines,
            {
                selectable: false,
                objectCaching: false,
                opacity: 1
            }));

        if (isHorizontal)
            canvasManager.plotText(`  ${measurementText}  `, "white", cord.x1, cord.y1 + ((cord.y2 - cord.y1) / 2), false, true, true, "black");
    },

    plotControlPoints: function (points, thickness, fillColor, isDashed) {
        var i;
        for (i = 0; i < points.length; i++) {
            const line = new fabric.Line([points[i].x1, points[i].y1, points[i].x2, points[i].y2], {
                strokeWidth: thickness,
                strokeDashArray: isDashed ? [thickness * 4, thickness * 2] : [],
                stroke: fillColor,
                selectable: false,
                id: i
            });

            sketchManager.sketchObject.service.sub.customLines.push(line);
            this.canvasObject.add(line);
        };

        for (i = 0; i < points.length; i++) {
            canvasManager.plotControlCircle(points[i].x2, points[i].y2, sketchManager.sketchObject.service.sub.customLines[i], sketchManager.sketchObject.service.sub.customLines[i + 1], i);
        }
    },
    plotControlCircle: function (left, top, line1, line2, i) {
        this.canvasObject.add(new fabric.Circle({
            left: left - sketchManager.sketchObject.service.sub.customRadious,
            top: top - sketchManager.sketchObject.service.sub.customRadious,
            strokeWidth: sketchManager.sketchObject.streets.borderThickness,
            radius: sketchManager.sketchObject.service.sub.customRadious,
            fill: app.colors.controlPointFill,
            stroke: app.colors.controlPointStroke,
            hasControls: false,
            hasBorders: false,
            line1: line1,
            line2: line2,
            id: i
        }));
    },


    // Canvas operations
    clearCanvas: function () {
        this.canvasObject.clear();
        this.canvasObject.backgroundColor = app.colors.backColor;
        this.plotGrid();
        canvasManager.finalizeRendering();
    },
    clearPaths: function () {
        var i = canvasManager.canvasObject._objects.length;
        while (i--) {
            const path = canvasManager.canvasObject._objects[i];
            if (path && path.type && path.type === "path")
                canvasManager.canvasObject._objects[i].remove();
        }

        canvasManager.finalizeRendering();
    },
    eraseSelectedPath: function () {
        if (canvasManager.canvasObject.getActiveObject() && canvasManager.canvasObject.getActiveObject().type === "path") {
            sketchManager.sketchObject.paths.forEach(function (item, index, list) {
                if (item.id === canvasManager.canvasObject.getActiveObject().id)
                    list.splice(index, 1);
            });
            canvasManager.canvasObject.getActiveObject().remove();
            canvasManager.finalizeRendering();
        }
    },
    toggleFreeDrawing: function (isEnabled) {
        canvasManager.canvasObject.discardActiveObject();
        canvasManager.canvasObject.isDrawingMode = isEnabled;
        canvasManager.canvasObject._objects.forEach(function (item) {
            if (item.type === "group" && item.id === "grid")
                item.opacity = isEnabled ? 1 : 0;
        });
        canvasManager.finalizeRendering();
    },
    finalizeRendering: function () {
        sketchUI.updateSkecthCalcPanel();
        canvasManager.canvasObject.renderAll();
        canvasManager.canvasObject.renderAll.bind(canvasManager.canvasObject)();
    }
};

var sketchManager = {
    // ## Sketch Object: contains all measurements and dimensions of objects to be plotted.
    sketchObject: {
        isImported: false,
        isFreeDrawing: false,
        input: { params: {}, customer: {}, site: {}, main: {}, sideMain: {} },
        canvas: {},
        streets: { mainStreet: {}, sideStreet: {} },
        building: { main: {}, garage: {} },
        service: { main: { tap: {} }, sub: { extension: {}, customCoords: [], customLines: [] } },
        paths: []
    },

    // ## Render Sketch: clear the canvas and draw all objects.
    plotSketchElements: function () { // Plot sketch elements on the canvas, such as streets and buildings
        this.sketchStreets();
        this.sketchBuilding();
        this.sketchMainServiceLine();
        this.sketchHandDrawing();
        this.sketchSubServiceLine();
        this.sketchMeasurements();
        canvasManager.finalizeRendering();
    },
    // ## Recalculate Skitch: determine the port size and recalculate all objects coordinates and dimensions.
    recalculateSkitch: function (isImporting) {
        if (!isImporting) { // If we are loading a sketch JSON, preserve the dimensions to generate that JSON and use it dispite the current dimensions.
            // Canvas dimensions
            this.sketchObject.canvas.width = ($(app.config.sketchContainerSelector).width() * 80 / 100);    // Set the canvas width to 80% of the parent container
            this.sketchObject.canvas.width = this.sketchObject.canvas.width > app.config.maxCanvasSize      // Max canvas size can be 1024
                ? app.config.maxCanvasSize
                : this.sketchObject.canvas.width;
            this.sketchObject.canvas.width = this.sketchObject.canvas.width < app.config.minCanvasSize      // Minimum canvas size is 450
                ? app.config.minCanvasSize
                : this.sketchObject.canvas.width;

            this.sketchObject.canvas.height = this.sketchObject.canvas.width / 4 * 3;                       // Calculate the height based on width using 4:3 aspect ration
            this.sketchObject.canvas.margin = this.sketchObject.canvas.width * 3 / 100;                     // Margin space on each edge to leave blank before draw objects. Percentage is 3%
        }

        // Streets dimensions
        this.sketchObject.streets.horizontalWidth = this.sketchObject.canvas.width * 18 / 100;              // The width of main street. Percentage is 18% of canvas width
        this.sketchObject.streets.verticalWidth = this.sketchObject.canvas.width * 15 / 100;                // The width of side street. Percentage is 15%  of canvas width
        this.sketchObject.streets.borderThickness = this.sketchObject.canvas.width * 0.15 / 100;            // The width of side street. Percentage is 0.15%  of canvas width

        // Building dimensions
        this.sketchObject.building.main.width = this.sketchObject.canvas.width * 20 / 100;
        this.sketchObject.building.main.height = this.sketchObject.canvas.height * 22 / 100;
        this.sketchObject.building.garage.width = this.sketchObject.building.main.width / 2;
        this.sketchObject.building.garage.height = this.sketchObject.building.main.height / 2;

        // Service Lines dimensions
        this.sketchObject.service.main.thickness = this.sketchObject.canvas.width * 0.3 / 100;
        this.sketchObject.service.sub.thickness = this.sketchObject.canvas.width * 0.2 / 100;
        this.sketchObject.service.sub.customRadious = this.sketchObject.canvas.width * 0.5 / 100;

        // Measurement line
        this.sketchObject.service.main.measurementThickness = this.sketchObject.canvas.width * 0.15 / 100;
    },
    // ## Resize Skitch: Resize canvas area based on container size.
    resizeSkitch: function () {
        canvasManager.canvasObject.setDimensions({ width: this.sketchObject.canvas.width, height: this.sketchObject.canvas.height });
    },
    // ## Clear canvas, custom objects array, and plot sketch elements from scratch
    resetSketch: function () {
        canvasManager.clearCanvas();
        sketchUI.toggleFreeDrawingUI(false);
        sketchManager.sketchObject.paths = [];
        sketchManager.sketchObject.service.sub.customCoords = [];
    },

    // ## Skitch Streets: Based on parameters, determine streets coordinates and dimension
    sketchStreets: function () {
        this.sketchObject.streets.mainStreet = {
            top: this.sketchObject.canvas.height - (this.sketchObject.canvas.margin * 2) - this.sketchObject.streets.horizontalWidth,
            height: this.sketchObject.streets.horizontalWidth
        };

        this.sketchObject.streets.sideStreet = {
            top: this.sketchObject.canvas.margin,
            height: this.sketchObject.canvas.height - (this.sketchObject.canvas.margin * 2),
            width: this.sketchObject.streets.verticalWidth
        };

        // Switch on the street template to calculate street position (Top, Left, Wdith, Height)
        switch (this.sketchObject.input.params.streetTemplate) {
            case 1: // Standard Right -> Main street bottom and side street on the right
                this.sketchObject.streets.sideStreet.left = this.sketchObject.canvas.width - this.sketchObject.streets.sideStreet.width - (this.sketchObject.canvas.margin * 2);

                this.sketchObject.streets.mainStreet.left = this.sketchObject.canvas.margin;
                this.sketchObject.streets.mainStreet.width = this.sketchObject.canvas.width - this.sketchObject.streets.sideStreet.width - (this.sketchObject.canvas.margin * 3);
                break;
            case 2: // Standard Left -> Main street bottom and side street on the left
                this.sketchObject.streets.sideStreet.left = (this.sketchObject.canvas.margin * 2);

                this.sketchObject.streets.mainStreet.left = this.sketchObject.streets.sideStreet.left + this.sketchObject.streets.sideStreet.width;
                this.sketchObject.streets.mainStreet.width = this.sketchObject.canvas.width - this.sketchObject.streets.sideStreet.left - this.sketchObject.streets.sideStreet.width - this.sketchObject.canvas.margin;
                break;
            case 3: // Other -> Main street bottom and no side streets
                this.sketchObject.streets.mainStreet.left = this.sketchObject.canvas.margin;
                this.sketchObject.streets.mainStreet.width = this.sketchObject.canvas.width - this.sketchObject.streets.mainStreet.left - this.sketchObject.canvas.margin;
                break;
            default:
        };

        if (this.sketchObject.input.params.streetTemplate === 1 || this.sketchObject.input.params.streetTemplate === 2) {

            canvasManager.plotRectangle(this.sketchObject.streets.sideStreet, this.sketchObject.streets.borderThickness, app.colors.streetColor, 1, app.colors.streetBorder, true);
            canvasManager.plotText(appHelper.parseAddress(sketchManager.sketchObject.input.site.nearestStreetName), "white",
                (this.sketchObject.streets.sideStreet.left + (this.sketchObject.streets.sideStreet.width / 2) + (sketchManager.sketchObject.canvas.margin / 1.5)).toFixed(1) / 1,
                (this.sketchObject.streets.sideStreet.top + (this.sketchObject.streets.sideStreet.height / 2)).toFixed(1) / 1, true, true);
        }

        canvasManager.plotRectangle(this.sketchObject.streets.mainStreet, this.sketchObject.streets.borderThickness, app.colors.streetColor, 1, app.colors.streetBorder, true);
        canvasManager.plotText(appHelper.parseAddress(sketchManager.sketchObject.input.customer.streetAddress), "white",
            (this.sketchObject.streets.mainStreet.left + this.sketchObject.canvas.margin).toFixed(1) / 1,
            (this.sketchObject.streets.mainStreet.top + (this.sketchObject.streets.mainStreet.height / 2) - (sketchManager.sketchObject.canvas.margin / 1.5)).toFixed(1) / 1, false, false);
    },
    // ## Skitch Building: Based on parameters, determine building coordinates and dimensions
    sketchBuilding: function () {
        switch (this.sketchObject.input.params.streetTemplate) {
            case 1: // Standard Right -> Main street bottom and side street on the right
                this.sketchObject.building.main.left = (this.sketchObject.canvas.width / 2) - this.sketchObject.streets.verticalWidth - this.sketchObject.building.main.width / 2;
                break;
            case 2: // Standard Left -> Main street bottom and side street on the left
                this.sketchObject.building.main.left = (this.sketchObject.canvas.width / 2) + this.sketchObject.streets.verticalWidth / 2;
                break;
            case 3: // Other -> Main street bottom and no side streets
                this.sketchObject.building.main.left = (this.sketchObject.canvas.width / 2) - this.sketchObject.building.main.width / 2;
                break;
            default:
        }

        switch (this.sketchObject.input.params.buildingTemplate) {
            case 2: // Garage Left -> Garage is to the left side of main building
                this.sketchObject.building.garage.left = this.sketchObject.building.main.left - this.sketchObject.building.garage.width;
                break;
            case 3: // Garage Right -> Garage is to the right side of main building
                this.sketchObject.building.garage.left = this.sketchObject.building.main.left + this.sketchObject.building.main.width;
                break;
            default:
        }

        this.sketchObject.building.main.top = (this.sketchObject.canvas.margin * 2.5);

        if (this.sketchObject.input.params.buildingTemplate === 2 || this.sketchObject.input.params.buildingTemplate === 3) {
            this.sketchObject.building.garage.top = this.sketchObject.building.main.top;
            canvasManager.plotRectangle(this.sketchObject.building.garage, this.sketchObject.streets.borderThickness, app.colors.buildingColor, 1, app.colors.objectBorder);

            canvasManager.plotText("Garage", "black",
                this.sketchObject.building.garage.left + (this.sketchObject.building.garage.width / 2),
                this.sketchObject.building.garage.top + (this.sketchObject.building.garage.height / 2), false, true, true);
        }

        canvasManager.plotRectangle(this.sketchObject.building.main, this.sketchObject.streets.borderThickness, app.colors.buildingColor, 1, app.colors.objectBorder);

        canvasManager.plotText("Main Building", "black",
            (this.sketchObject.building.main.left + (this.sketchObject.building.main.width / 2)).toFixed(1) / 1,
            (this.sketchObject.building.main.top + (this.sketchObject.building.main.height / 2)).toFixed(1) / 1, false, true, true);
    },
    // ## Skitch Main Service Line: Based on parameters, determine service lines coordinates and dimensions
    sketchMainServiceLine: function () {
        var curbLocation = (this.sketchObject.input.params.tapLocation === 1) ? (-(this.sketchObject.canvas.margin / 2)) : (this.sketchObject.canvas.margin / 2);
        const streetLocation = (this.sketchObject.input.params.streetTemplate === 1) ? 0 : -this.sketchObject.streets.sideStreet.width;

        switch (this.sketchObject.input.params.streetTemplate) {
            case 1: // Standard Right -> Main street bottom and side street on the right
            case 2: // Standard Left -> Main street bottom and side street on the left
                this.sketchObject.service.main.y1 = this.sketchObject.streets.sideStreet.top + this.sketchObject.canvas.margin;
                this.sketchObject.service.main.y2 = this.sketchObject.streets.sideStreet.height;
                curbLocation = (this.sketchObject.input.params.streetTemplate === 1) ? curbLocation : -curbLocation;

                switch (this.sketchObject.input.params.mainLocation) {
                    case 1: // Short Side -> Near to the building
                        this.sketchObject.service.main.x1 = this.sketchObject.streets.sideStreet.left + curbLocation - streetLocation;
                        this.sketchObject.service.main.x2 = this.sketchObject.service.main.x1;
                        break;
                    case 2: // Long Side -> Far from the building other side of street
                        this.sketchObject.service.main.x1 = this.sketchObject.streets.sideStreet.left + this.sketchObject.streets.sideStreet.width - curbLocation + streetLocation;
                        this.sketchObject.service.main.x2 = this.sketchObject.service.main.x1;
                        break;
                    default:
                };

                break;
            case 3: // Other -> Main street bottom and no side streets
                this.sketchObject.service.main.x1 = this.sketchObject.streets.mainStreet.left + this.sketchObject.canvas.margin;
                this.sketchObject.service.main.x2 = this.sketchObject.streets.mainStreet.width;

                switch (this.sketchObject.input.params.mainLocation) {
                    case 1: // Short Side -> Near to the building
                        this.sketchObject.service.main.y1 = this.sketchObject.streets.mainStreet.top + curbLocation;
                        this.sketchObject.service.main.y2 = this.sketchObject.service.main.y1;
                        break;
                    case 2: // Long Side -> Far from the building other side of street
                        this.sketchObject.service.main.y1 = this.sketchObject.streets.mainStreet.top + this.sketchObject.streets.mainStreet.height - curbLocation;
                        this.sketchObject.service.main.y2 = this.sketchObject.service.main.y1;
                        break;
                    default:
                };
                break;
            default:
        };

        canvasManager.plotLine(this.sketchObject.service.main, this.sketchObject.service.main.thickness, app.colors.mainServiceLine, true);
    },
    // ## Skitch Sub-Service Line: Based on parameters, determine sub-service lines coordinates and dimensions
    sketchSubServiceLine: function () {
        var i;
        var subLineSuffexY = 0;
        var subLineSuffexX = 0;
        var multiplier;
        var pointStart;
        var buildingMeterCoords;

        this.sketchObject.service.sub.extension = {};
        //this.sketchObject.service.sub.customCoords = [];
        this.sketchObject.service.sub.customLines = [];
        this.sketchObject.service.sub.hasExtension = false;

        switch (this.sketchObject.input.params.streetTemplate) {
            case 1: // Standard Right -> Main street bottom and side street on the right
                if (this.sketchObject.input.params.meterLocation === 1 ||
                    this.sketchObject.input.params.meterLocation === 2 ||
                    this.sketchObject.input.params.meterLocation === 3) {
                    subLineSuffexY = this.sketchObject.canvas.margin;
                    subLineSuffexX = this.sketchObject.building.garage.width;
                }
                else if (this.sketchObject.input.params.meterLocation === 4 ||
                    this.sketchObject.input.params.meterLocation === 5 ||
                    this.sketchObject.input.params.meterLocation === 6) {
                    subLineSuffexY = this.sketchObject.building.main.height - this.sketchObject.canvas.margin;
                    subLineSuffexX = 0;
                }

                this.sketchObject.service.sub.x1 = this.sketchObject.service.main.x1;
                this.sketchObject.service.sub.x2 = this.sketchObject.building.main.left + this.sketchObject.building.main.width + ((this.sketchObject.input.params.buildingTemplate === 3) ? subLineSuffexX : 0);
                this.sketchObject.service.sub.y1 = this.sketchObject.building.main.top + subLineSuffexY;
                this.sketchObject.service.sub.y2 = this.sketchObject.service.sub.y1;

                // If custom service line requested, use the above calculations but also add the requested number of extension lines
                if (this.sketchObject.input.params.meterLocation === 6) {
                    multiplier = 1.5;
                    pointStart = 0;
                    buildingMeterCoords = this.sketchObject.service.sub.x2;
                    this.sketchObject.service.sub.x2 = this.sketchObject.service.sub.x1 - (this.sketchObject.canvas.margin * multiplier);
                    if (this.sketchObject.input.params.mainLocation === 2) // Long side
                        this.sketchObject.service.sub.x2 -= this.sketchObject.streets.verticalWidth;

                    pointStart = this.sketchObject.service.sub.x2;

                    if (sketchManager.sketchObject.service.sub.customCoords.length < 1)
                        for (i = 0; i < this.sketchObject.input.params.controlPoints; i++) {
                            this.sketchObject.service.sub.customCoords.push({
                                x1: pointStart,
                                x2: (i === this.sketchObject.input.params.controlPoints - 1) ? buildingMeterCoords : pointStart - (this.sketchObject.canvas.margin * multiplier),
                                y1: this.sketchObject.service.sub.y1,
                                y2: this.sketchObject.service.sub.y1
                            });

                            pointStart -= (this.sketchObject.canvas.margin * multiplier);
                        }
                    else {
                        this.sketchObject.service.sub.customCoords[0].x1 = pointStart;
                        this.sketchObject.service.sub.customCoords[0].y1 = this.sketchObject.service.sub.y1;

                        this.sketchObject.service.sub.customCoords[this.sketchObject.input.params.controlPoints - 1].x2 = buildingMeterCoords;
                        this.sketchObject.service.sub.customCoords[this.sketchObject.input.params.controlPoints - 1].y2 = this.sketchObject.service.sub.y1;
                    }

                    canvasManager.plotControlPoints(this.sketchObject.service.sub.customCoords, this.sketchObject.service.main.thickness, app.colors.mainServiceLine, false);
                }
                break;
            case 2: // Standard Left -> Main street bottom and side street on the left
                if (this.sketchObject.input.params.meterLocation === 1 ||
                    this.sketchObject.input.params.meterLocation === 2 ||
                    this.sketchObject.input.params.meterLocation === 3) {
                    subLineSuffexY = this.sketchObject.canvas.margin;
                    subLineSuffexX = this.sketchObject.building.garage.width;
                }
                else if (this.sketchObject.input.params.meterLocation === 4 ||
                    this.sketchObject.input.params.meterLocation === 5 ||
                    this.sketchObject.input.params.meterLocation === 6) {
                    subLineSuffexY = this.sketchObject.building.main.height - this.sketchObject.canvas.margin;
                    subLineSuffexX = 0;
                }

                this.sketchObject.service.sub.x1 = this.sketchObject.service.main.x1;
                this.sketchObject.service.sub.x2 = this.sketchObject.building.main.left - ((this.sketchObject.input.params.buildingTemplate === 2) ? subLineSuffexX : 0);
                this.sketchObject.service.sub.y1 = this.sketchObject.building.main.top + subLineSuffexY;
                this.sketchObject.service.sub.y2 = this.sketchObject.service.sub.y1;

                // If custom service line requested, use the above calculations but also add the requested number of extension lines
                if (this.sketchObject.input.params.meterLocation === 6) {
                    multiplier = 1.5;
                    pointStart = 0;
                    buildingMeterCoords = this.sketchObject.service.sub.x2;
                    this.sketchObject.service.sub.x2 = this.sketchObject.service.sub.x1 + (this.sketchObject.canvas.margin * multiplier);
                    if (this.sketchObject.input.params.mainLocation === 2) // Long side
                        this.sketchObject.service.sub.x2 += this.sketchObject.streets.verticalWidth;

                    pointStart = this.sketchObject.service.sub.x2;
                    if (sketchManager.sketchObject.service.sub.customCoords.length < 1)
                        for (i = 0; i < this.sketchObject.input.params.controlPoints; i++) {
                            this.sketchObject.service.sub.customCoords.push({
                                x1: pointStart,
                                x2: (i === this.sketchObject.input.params.controlPoints - 1)
                                    ? buildingMeterCoords
                                    : pointStart + (this.sketchObject.canvas.margin * multiplier),
                                y1: this.sketchObject.service.sub.y1,
                                y2: this.sketchObject.service.sub.y1
                            });

                            pointStart += (this.sketchObject.canvas.margin * multiplier);
                        }
                    else {
                        this.sketchObject.service.sub.customCoords[0].x1 = pointStart;
                        this.sketchObject.service.sub.customCoords[0].y1 = this.sketchObject.service.sub.y1;

                        this.sketchObject.service.sub.customCoords[this.sketchObject.input.params.controlPoints - 1].x2 = buildingMeterCoords;
                        this.sketchObject.service.sub.customCoords[this.sketchObject.input.params.controlPoints - 1].y2 = this.sketchObject.service.sub.y1;
                    }

                    canvasManager.plotControlPoints(this.sketchObject.service.sub.customCoords, this.sketchObject.service.main.thickness, app.colors.mainServiceLine, false);
                }
                break;
            case 3: // Other -> Main street bottom and no side streets
                this.sketchObject.service.sub.y2 = this.sketchObject.service.main.y2;
                if (this.sketchObject.input.params.buildingTemplate === 1)
                    this.sketchObject.building.garage = { top: 0, left: 0, width: 0, height: 0 };

                this.sketchObject.service.sub.hasExtension = true;
                switch (this.sketchObject.input.params.meterLocation) {
                    case 1: // Front Side -> Meter at the front side
                        this.sketchObject.service.sub.x1 = this.sketchObject.building.main.left + (this.sketchObject.building.main.width / 2);
                        this.sketchObject.service.sub.x2 = this.sketchObject.service.sub.x1;
                        this.sketchObject.service.sub.y1 = this.sketchObject.building.main.top + this.sketchObject.building.main.height;
                        this.sketchObject.service.sub.hasExtension = false;
                        break;
                    case 2: // Left Side -> Meter at the left side
                        this.sketchObject.service.sub.x1 = this.sketchObject.building.main.left
                            - ((this.sketchObject.input.params.buildingTemplate === 2) ? this.sketchObject.building.garage.width : 0)
                            - this.sketchObject.canvas.margin;
                        this.sketchObject.service.sub.x2 = this.sketchObject.service.sub.x1;
                        this.sketchObject.service.sub.y1 = this.sketchObject.building.main.top + this.sketchObject.canvas.margin;

                        this.sketchObject.service.sub.extension.x2 = this.sketchObject.service.sub.x1 + this.sketchObject.canvas.margin;
                        break;
                    case 3: // Right Side -> Meter at the right side
                        this.sketchObject.service.sub.x1 = this.sketchObject.building.main.left
                            + this.sketchObject.building.main.width
                            + ((this.sketchObject.input.params.buildingTemplate === 3) ? this.sketchObject.building.garage.width : 0)
                            + this.sketchObject.canvas.margin;
                        this.sketchObject.service.sub.x2 = this.sketchObject.service.sub.x1;
                        this.sketchObject.service.sub.y1 = this.sketchObject.building.main.top + this.sketchObject.canvas.margin;

                        this.sketchObject.service.sub.extension.x2 = this.sketchObject.service.sub.x1 - this.sketchObject.canvas.margin;
                        break;
                    case 4: // Front Left Side -> Meter at the front left side
                        this.sketchObject.service.sub.x1 = this.sketchObject.building.main.left - this.sketchObject.canvas.margin;
                        this.sketchObject.service.sub.x2 = this.sketchObject.service.sub.x1;
                        this.sketchObject.service.sub.y1 = this.sketchObject.building.main.top + this.sketchObject.building.main.height - this.sketchObject.canvas.margin;

                        this.sketchObject.service.sub.extension.x2 = this.sketchObject.service.sub.x1 + this.sketchObject.canvas.margin;
                        break;
                    case 5: // Front Right Side -> Meter at the front right side
                        this.sketchObject.service.sub.x1 = this.sketchObject.building.main.left + this.sketchObject.building.main.width + this.sketchObject.canvas.margin;
                        this.sketchObject.service.sub.x2 = this.sketchObject.service.sub.x1;
                        this.sketchObject.service.sub.y1 = this.sketchObject.building.main.top + this.sketchObject.building.main.height - this.sketchObject.canvas.margin;

                        this.sketchObject.service.sub.extension.x2 = this.sketchObject.service.sub.x1 - this.sketchObject.canvas.margin;
                        break;
                    case 6: // Custom service line requested.
                        multiplier = 1.25;
                        pointStart = 0;
                        buildingMeterCoords = this.sketchObject.building.main.top + this.sketchObject.building.main.height;
                        this.sketchObject.service.sub.x1 = this.sketchObject.building.main.left + (this.sketchObject.building.main.width / 2);
                        this.sketchObject.service.sub.x2 = this.sketchObject.service.sub.x1;
                        this.sketchObject.service.sub.y1 = this.sketchObject.service.sub.y2 - (this.sketchObject.canvas.margin * multiplier);
                        this.sketchObject.service.sub.hasExtension = false;

                        if (this.sketchObject.input.params.mainLocation === 2) // Long side
                        {
                            this.sketchObject.service.sub.y1 -= this.sketchObject.streets.verticalWidth;
                            if (this.sketchObject.input.params.tapLocation === 1)
                                this.sketchObject.service.sub.y1 -= this.sketchObject.canvas.margin;
                        }

                        pointStart = this.sketchObject.service.sub.y1;

                        if (sketchManager.sketchObject.service.sub.customCoords.length < 1)
                            for (i = 0; i < this.sketchObject.input.params.controlPoints; i++) {
                                this.sketchObject.service.sub.customCoords.push({
                                    x1: this.sketchObject.service.sub.x1,
                                    x2: this.sketchObject.service.sub.x1,
                                    y1: pointStart,
                                    y2: (i === this.sketchObject.input.params.controlPoints - 1) ? buildingMeterCoords : pointStart - (this.sketchObject.canvas.margin * multiplier)
                                });

                                pointStart -= (this.sketchObject.canvas.margin * multiplier);
                            }
                        else {
                            this.sketchObject.service.sub.customCoords[0].x1 = this.sketchObject.service.sub.x1;
                            this.sketchObject.service.sub.customCoords[0].y1 = pointStart;

                            this.sketchObject.service.sub.customCoords[this.sketchObject.input.params.controlPoints - 1].x2 = this.sketchObject.service.sub.x1;
                            this.sketchObject.service.sub.customCoords[this.sketchObject.input.params.controlPoints - 1].y2 = buildingMeterCoords;
                        }

                        canvasManager.plotControlPoints(this.sketchObject.service.sub.customCoords, this.sketchObject.service.main.thickness, app.colors.mainServiceLine, false);
                        break;
                    default:
                };

                break;
            default:
        };

        // Draw the tab rectangle
        if (this.sketchObject.input.params.streetTemplate === 3) {
            this.sketchObject.service.main.tap.top = this.sketchObject.service.sub.y2 - (this.sketchObject.canvas.margin / 2);
            this.sketchObject.service.main.tap.left = this.sketchObject.service.sub.x1 - (this.sketchObject.canvas.margin);
        }
        else if (this.sketchObject.input.params.streetTemplate === 1 || this.sketchObject.input.params.streetTemplate === 2) {
            this.sketchObject.service.main.tap.top = this.sketchObject.service.sub.y2 - (this.sketchObject.canvas.margin);
            this.sketchObject.service.main.tap.left = this.sketchObject.service.sub.x1 - (this.sketchObject.canvas.margin / 2);
        }

        this.sketchObject.service.main.tap.width = (this.sketchObject.service.sub.x1 - this.sketchObject.service.main.tap.left) * 2;
        this.sketchObject.service.main.tap.height = (this.sketchObject.service.sub.y2 - this.sketchObject.service.main.tap.top) * 2;

        // Identify and draw the sub-extension line to the building
        if (this.sketchObject.service.sub.hasExtension) {
            this.sketchObject.service.sub.extension.x1 = this.sketchObject.service.sub.x1;
            this.sketchObject.service.sub.extension.y1 = this.sketchObject.service.sub.y1;
            this.sketchObject.service.sub.extension.y2 = this.sketchObject.service.sub.extension.y1;

            canvasManager.plotLine(this.sketchObject.service.sub.extension, this.sketchObject.service.main.thickness, app.colors.mainServiceLine, false);
        }

        canvasManager.plotLine(this.sketchObject.service.sub, this.sketchObject.service.main.thickness, app.colors.mainServiceLine, false);
        canvasManager.plotRectangle(this.sketchObject.service.main.tap, this.sketchObject.service.sub.thickness, "white", 0.75, app.colors.objectBorder);
    },
    // ## Skitch Measurments: Based on parameters, determine measurements lines coordinates and dimensions
    sketchMeasurements: function () {
        var measurementsCoords = {
            mainStreet: {},
            curbToHouse: {},
            meterSetBack: {}
        }
        switch (this.sketchObject.input.params.streetTemplate) {
            case 1: // Standard Right -> Main street bottom and side street on the right
                // Plot the main street width measurement line
                measurementsCoords.mainStreet = {
                    x: this.sketchObject.streets.mainStreet.left + (this.sketchObject.streets.mainStreet.width / 2)
                };
                break;
            case 2: // Standard Left -> Main street bottom and side street on the left
                measurementsCoords.mainStreet = {
                    x: this.sketchObject.streets.mainStreet.left + (this.sketchObject.streets.mainStreet.width / 2)
                };
                break;
            case 3: // Other -> Main street bottom and no side streets
                if (this.sketchObject.input.params.meterLocation === 1 ||
                    this.sketchObject.input.params.meterLocation === 3 ||
                    this.sketchObject.input.params.meterLocation === 5 ||
                    this.sketchObject.input.params.meterLocation === 6) {
                    measurementsCoords.mainStreet = {
                        x: this.sketchObject.service.sub.x1 + (this.sketchObject.canvas.margin * 2)
                    };
                }
                else if (this.sketchObject.input.params.meterLocation === 2 ||
                    this.sketchObject.input.params.meterLocation === 4) {
                    measurementsCoords.mainStreet = {
                        x: this.sketchObject.service.sub.x1 - (this.sketchObject.canvas.margin * 2)
                    };
                };

                measurementsCoords.curbToHouse = {
                    x1: measurementsCoords.mainStreet.x,
                    x2: measurementsCoords.mainStreet.x,
                    y1: this.sketchObject.service.sub.y1,
                    y2: this.sketchObject.streets.mainStreet.top
                }

                if (this.sketchObject.input.params.meterLocation !== 6)
                    // Plot the main street width measurement line
                    canvasManager.plotMeasurementLine(measurementsCoords.curbToHouse, this.sketchObject.service.main.measurementThickness, app.colors.measurementLine, false, `${sketchManager.sketchObject.input.site.houseToCurb} feet`, true);
            default:
                break;
        };

        // Plot the main street width measurement line
        canvasManager.plotMeasurementLine({
            x1: measurementsCoords.mainStreet.x,
            x2: measurementsCoords.mainStreet.x,
            y1: this.sketchObject.streets.mainStreet.top,
            y2: this.sketchObject.streets.mainStreet.top + this.sketchObject.streets.mainStreet.height
        }, this.sketchObject.service.main.measurementThickness, app.colors.measurementLine, false, `${sketchManager.sketchObject.input.site.streetWidth} feet`, true);
    },
    // ## Add loaded free drawing objects to the canvas
    sketchHandDrawing: function () {
        canvasManager.clearPaths();
        for (let j = 0; j < sketchManager.sketchObject.paths.length; j++) {
            sketchManager.sketchObject.paths[j].selectable = false;
            canvasManager.canvasObject.add(fabric.Path.fromObject(sketchManager.sketchObject.paths[j]));
        }
        canvasManager.finalizeRendering();
    }
};

var appManager = {
    initApp: function () {
        canvasManager.initCanvas();
        sketchUI.bindUIComponents();
        sketchUI.bindUIResizeEvent();
        appManager.generateSketch();
    },
    generateSketch: function () {
        sketchManager.sketchObject.isImported = false;      // Generated and not imported from JSON
        sketchUI.fetchSketchParams();                       // Get user paramaters
        sketchManager.recalculateSkitch();                  // Recalculate dimensions based on the client size
        sketchManager.resizeSkitch();                       // Resize canvas based on client size
        sketchManager.resetSketch();                        // Reset canvas and any custom elements arrays
        sketchManager.plotSketchElements();                 // Plot sketch elements such as streets and buildings
        sketchUI.updateSkecthCalcPanel();                   // Update the clac JSON panel
    },
    loadSketch: function (sketchObj) {
        sketchManager.resetSketch();                        // Reset canvas and any custom elements arrays
        sketchManager.sketchObject = JSON.parse(sketchObj); // Read the sketch object from loaded JSON and replace the current object
        sketchManager.sketchObject.isImported = true;       // This is a loaded sketch not generated
        sketchManager.recalculateSkitch(true);              // Recalculate dimensions based on the client size
        sketchManager.resizeSkitch();                       // Resize canvas based on client size
        sketchManager.plotSketchElements();                 // Plot sketch elements such as streets and buildings
        sketchUI.updateSkecthCalcPanel();                   // Update the clac JSON panel
        sketchUI.toggleFreeDrawingUI(false);                // Disable free mode, untill user enable it.
    }
};

var sketchUI = {
    bindUIComponents: function () {
        // Bind UI Compnents Events
        $("#menuToggler").on("click", function () {
            sketchUI.resizeSequence();
        });

        $("#generateSketch").on("click", function () {
            $("#sketchInputPanel").removeClass("activePanel").addClass("inactivePanel");
            $("#sketchOutputPanel").removeClass("inactivePanel").addClass("activePanel");

            $("#generateSketchLinkMenu").addClass("active");
            $("#editSketchLinkMenu").removeClass("active");

            appManager.generateSketch();
        });
        $("#editSketch").on("click", function () {
            $("#sketchInputPanel").removeClass("inactivePanel").addClass("activePanel");
            $("#sketchOutputPanel").removeClass("activePanel").addClass("inactivePanel");

            $("#editSketchLinkMenu").addClass("active");
            $("#generateSketchLinkMenu").removeClass("active");

            canvasManager.clearCanvas();
        });
        $("#generateSketchLink").on("click", function () {
            $("#sketchInputPanel").removeClass("activePanel").addClass("inactivePanel");
            $("#sketchOutputPanel").removeClass("inactivePanel").addClass("activePanel");
            $("#generateSketchLinkMenu").addClass("active");
            $("#editSketchLinkMenu").removeClass("active");
            appManager.generateSketch();
        });
        $("#editSketchLink").on("click", function () {
            $("#sketchInputPanel").removeClass("inactivePanel").addClass("activePanel");
            $("#sketchOutputPanel").removeClass("activePanel").addClass("inactivePanel");
            $("#editSketchLinkMenu").addClass("active");
            $("#generateSketchLinkMenu").removeClass("active");
            canvasManager.clearCanvas();
        });
        $("#freeDrawing").on("click", function () {
            sketchUI.toggleFreeDrawingUI(!sketchManager.sketchObject.isFreeDrawing);
        });

        // Sketch IO Operations
        $("#exportSketchImage").on("click", function () {
            sketchIO.exportImage();
        });
        $("#exportSketchJSON").on("click", function () {
            sketchIO.exportJSON();
        });
        $("#importSketch").on("click", function () {
            sketchIO.importJSON();
        });

        // Sketch Free Drawing Operations
        $("#clearFreeDrawing").on("click", function () {
            sketchManager.sketchObject.paths = [];
            canvasManager.clearPaths();
        });
        $("#eraseSelectedFreeDrawing").on("click", function () {
            canvasManager.eraseSelectedPath();
        });

        $(".touchspin-postfix").TouchSpin({
            min: 1,
            max: 25,
            step: 1,
            decimals: 0,
            prefix: "Strok"
        }).on("touchspin.on.startspin", function () {
            canvasManager.canvasObject.freeDrawingBrush.width = parseInt($(this).val());
        });

        $(".colorpicker-show-alpha").spectrum({
            showAlpha: true,
            change: function (color) {
                canvasManager.canvasObject.freeDrawingBrush.color = color.toRgbString();
            },
            hide: function (color) {
                canvasManager.canvasObject.freeDrawingBrush.color = color.toRgbString();
            },
            move: function (color) {
                canvasManager.canvasObject.freeDrawingBrush.color = color.toRgbString();
            }
        });
    },
    bindUIResizeEvent: function () {
        $(window).resize(function () {
            sketchUI.resizeSequence();
        }).resize();
    },
    resizeSequence: function () {
        let resizeTimeout;
        const containerSize = ($(app.config.sketchContainerSelector).width() * 80 / 100);

        if (containerSize > 1024 && sketchManager.sketchObject.canvas.width === 1024) return;   // the container is larger than 1024, no need to resize
        if (sketchManager.sketchObject.canvas.width === containerSize) return;                  // the canvas and container size are equal, no need to resize
        if (sketchManager.sketchObject.input.params.meterLocation === 6) return;                // the meter location is custom
        if (canvasManager.canvasObject.isDrawingMode) return;
        if (sketchManager.sketchObject.isImported) return;

        // ReSharper disable once UsageOfPossiblyUnassignedValue
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(function () {
            appManager.generateSketch();
        }, 250);
    },
    fetchSketchParams: function () {
        sketchManager.sketchObject.input = {
            customer: {
                bcaNumber: $("#bcaNumber").val(),
                requestDate: $("#requestDate").val(),
                accountExecutive: $("#buildingTemplates option:selected").text(),
                customerName: $("#customerName").val(),
                contactNumber: $("#contactNumber").val(),
                customerEmail: $("#customerEmail").val(),
                streetAddress: $("#streetAddress").val(),
                county: $("#countyList option:selected").text(),
                twon: $("#townList option:selected").text(),
                zipCode: $("#zipCode").val()
            },
            params: {
                streetTemplate: parseInt($("#streetTemplates").val()),
                buildingTemplate: parseInt($("#buildingTemplates").val()),
                meterLocation: parseInt($("#meterLocation").val()),
                controlPoints: parseInt($("#controlPoints").val()),
                tapLocation: parseInt($("#tapLocation").val()),
                mainLocation: parseInt($("#mainLocation").val())
            },
            site: {
                nearestStreetName: $("#nearestStreetName").val(),
                preferredLocation: $("#preferredLocation option:selected").text(),
                meterSetback: parseInt($("#meterSetback").val()),
                houseToCurb: parseInt($("#houseToCurb").val()),
                streetWidth: parseInt($("#streetWidth").val()),
                distanceToNearesrStreet: parseInt($("#distanceToNearesrStreet").val())
            },
            main: {
                mainType: $("#mainType option:selected").text(),
                mainSize: $("#mainSize option:selected").text(),
                systemNOP: $("#systemNOP option:selected").text(),
                mainToCurb: parseInt($("#mainToCurb").val())
            },
            sideMain: {
                sideMainType: $("#sideMainType option:selected").text(),
                sideMainSize: $("#sideMainSize option:selected").text(),
                sideSystemNOP: $("#sideSystemNOP option:selected").text(),
                sideMainToCurb: parseInt($("#sideMainToCurb").val())
            }
        };
        sketchUI.fetchSketchCode();

        $("#bcaNumberLabel").text($("#bcaNumber").val());
        $("#customerNameLabel").text($("#customerName").val());
        $("#contactNumberLabel").text($("#contactNumber").val());
        $("#streetAddressLabel").text($("#streetAddress").val());
        $("#mainToCurbLabel").text($("#mainToCurb").val());
        $("#nearestStreetNameLabel").text($("#nearestStreetName").val());
    },
    fetchSketchCode: function () {
        var sketchCode = $("#streetTemplates option:selected").text().split("-")[0] + "-";
        sketchCode += $("#buildingTemplates option:selected").text().split("-")[0] + "-";
        sketchCode += $("#meterLocation option:selected").text().split("-")[0] + "-";
        sketchCode += $("#tapLocation option:selected").text().split("-")[0] + "-";
        sketchCode += $("#mainLocation option:selected").text().split("-")[0];
        $("#templateCodeLabel").text(sketchCode);
    },
    toggleFreeDrawingUI: function (isEnabled) {
        if (isEnabled) {
            $("#freeDrawing").removeClass("bg-grey-300").addClass("btn-warning");
            $("#freeDrawingToolPanel").removeClass("inactivePanel").addClass("activePanel");

        } else {
            $("#freeDrawing").removeClass("btn-warning").addClass("bg-grey-300");
            $("#freeDrawingToolPanel").removeClass("activePanel").addClass("inactivePanel");
        }

        sketchManager.sketchObject.isFreeDrawing = isEnabled;
        canvasManager.toggleFreeDrawing(isEnabled);
    },
    updateSkecthCalcPanel: function () {
        const editor = ace.edit("sketchCalcEditor");
        const aceSession = editor.getSession();
        editor.setValue(JSON.stringify(sketchManager.sketchObject), -1);
        editor.setTheme("ace/theme/monokai");
        editor.setShowPrintMargin(false);
        editor.setOptions({
            readOnly: true,
            maxLines: Infinity
        });
        aceSession.setMode("ace/mode/json");
        aceSession.setValue(window.js_beautify(aceSession.getValue(), { indent_size: 2 }));

        // Fold Code
        //window.setTimeout(function () {
        //    aceSession.foldAll(1, aceSession.getLength());
        //}, 500);
    }
}

var sketchIO = {
    exportImage: function () {
        const img = canvasManager.canvasObject.toDataURL("image/png");
        const a = document.createElement("a");
        const file = appHelper.dataURItoBlob(img);

        a.href = URL.createObjectURL(file);
        a.download = "sketch.png";
        a.click();
    },
    exportJSON: function () {
        const a = document.createElement("a");
        //const file = new Blob([JSON.stringify(canvasManager.canvasObject.toDatalessJSON())], { type: "text/json" });
        const file = new Blob([JSON.stringify(sketchManager.sketchObject)], { type: "text/json" });
        a.href = URL.createObjectURL(file);
        a.download = "sketch.json";
        a.click();
    },
    importJSON: function () {
        const element = document.createElement("div");
        element.innerHTML = '<input type="file">';
        var fileInput = element.firstChild;

        fileInput.addEventListener("change", function () {
            const file = fileInput.files[0];
            if (file.name.match(/\.(json)$/)) {
                const reader = new FileReader();
                reader.onload = function () {
                    appManager.loadSketch(reader.result);
                };
                reader.readAsText(file);
            } else {
                alert("File not supported, *.json files only");
            }
        });

        fileInput.click();
    }
};

var appHelper = {
    dataURItoBlob: function (dataUri) {
        // convert base64 to raw binary data held in a string
        // doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this
        const byteString = atob(dataUri.split(",")[1]);

        // write the bytes of the string to an ArrayBuffer
        const ab = new ArrayBuffer(byteString.length);
        const ia = new Uint8Array(ab);
        for (let i = 0; i < byteString.length; i++) {
            ia[i] = byteString.charCodeAt(i);
        }

        // write the ArrayBuffer to a blob, and you're done
        const bb = new Blob([ab]);
        return bb;
    },
    shadeColor: function (color, percent) {
        var r = parseInt(color.substring(1, 3), 16);
        var g = parseInt(color.substring(3, 5), 16);
        var b = parseInt(color.substring(5, 7), 16);

        r = parseInt(r * (100 + percent) / 100);
        g = parseInt(g * (100 + percent) / 100);
        b = parseInt(b * (100 + percent) / 100);

        r = (r < 255) ? r : 255;
        g = (g < 255) ? g : 255;
        b = (b < 255) ? b : 255;

        const rr = ((r.toString(16).length === 1) ? `0${r.toString(16)}` : r.toString(16));
        const gg = ((g.toString(16).length === 1) ? `0${g.toString(16)}` : g.toString(16));
        const bb = ((b.toString(16).length === 1) ? `0${b.toString(16)}` : b.toString(16));

        return "#" + rr + gg + bb;
    },
    parseAddress: function (addr) {
        if (!addr) return "";

        const r = {
            num: null,
            street: null,
            type: null
        };
        const addressComponents = addr.split(/\s/g);
        r.num = Number.parseInt(addressComponents.shift());

        if (isNaN(r.num) && addressComponents.length === 0)
            return addr;

        r.type = addressComponents.pop();
        r.street = addressComponents.join(" ");

        return r.street + " " + r.type;
    }
}

$(function () {
    app.initApp();
});